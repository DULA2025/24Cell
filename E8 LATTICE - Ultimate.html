<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E8 Root System - Ultimate WebGL Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #0a0a0a 0%, #000000 100%);
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        canvas {
            display: block;
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            min-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: opacity 0.3s ease;
        }
        
        h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
            background: linear-gradient(90deg, #00ffff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }
        
        #fps-counter {
            font-size: 18px;
            color: #00ff00;
            margin-bottom: 15px;
            font-family: 'Courier New', monospace;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-value {
            color: #ffffff;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ffff, #00ff88);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ffff, #00ff88);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        button {
            padding: 10px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 6px;
            color: #00ffff;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.6);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-top: 15px;
        }
        
        .preset-btn {
            grid-column: span 1;
        }
        
        #stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
            font-size: 11px;
            color: #888;
        }
        
        .glow-effect {
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff; }
            to { text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff; }
        }
        
        #toggle-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            color: #00ffff;
            font-size: 14px;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        #toggle-panel:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div id="info-panel">
        <h1 class="glow-effect">E8 Root System</h1>
        <div id="fps-counter">FPS: --</div>
        
        <div class="control-group">
            <div class="control-label">
                <span>Rotation Speed</span>
                <span class="control-value" id="speed-value">1.0x</span>
            </div>
            <input type="range" id="rotation-speed" min="0" max="5" step="0.1" value="1">
        </div>
        
        <div class="control-group">
            <div class="control-label">
                <span>Point Size</span>
                <span class="control-value" id="size-value">0.10</span>
            </div>
            <input type="range" id="point-size" min="0.02" max="0.3" step="0.01" value="0.1">
        </div>
        
        <div class="control-group">
            <div class="control-label">
                <span>Line Opacity</span>
                <span class="control-value" id="line-opacity-value">0.20</span>
            </div>
            <input type="range" id="line-opacity" min="0" max="1" step="0.05" value="0.2">
        </div>
        
        <div class="control-group">
            <div class="control-label">
                <span>Glow Intensity</span>
                <span class="control-value" id="glow-value">0.5</span>
            </div>
            <input type="range" id="glow-intensity" min="0" max="2" step="0.1" value="0.5">
        </div>
        
        <div class="control-group">
            <div class="control-label">
                <span>Camera Distance</span>
                <span class="control-value" id="distance-value">3.0</span>
            </div>
            <input type="range" id="camera-distance" min="1" max="8" step="0.1" value="3">
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="auto-rotate" checked>
            <label for="auto-rotate">Auto Rotate</label>
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="show-lines" checked>
            <label for="show-lines">Show Lines</label>
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="bloom-effect">
            <label for="bloom-effect">Bloom Effect</label>
        </div>
        
        <div class="button-group">
            <button onclick="resetCamera()">Reset Camera</button>
            <button onclick="randomizeRotation()">Random Spin</button>
        </div>
        
        <div class="preset-buttons">
            <button class="preset-btn" onclick="applyPreset('cosmic')">ðŸŒŒ Cosmic</button>
            <button class="preset-btn" onclick="applyPreset('neon')">âš¡ Neon</button>
            <button class="preset-btn" onclick="applyPreset('minimal')">âœ¨ Minimal</button>
            <button class="preset-btn" onclick="applyPreset('intense')">ðŸ”¥ Intense</button>
        </div>
        
        <div id="stats">
            <div>Vertices: <span id="vertex-count">--</span></div>
            <div>Lines: <span id="line-count">--</span></div>
        </div>
    </div>
    
    <div id="toggle-panel" onclick="togglePanel()">â˜° Controls</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
    (function() { // Start of IIFE to prevent global scope pollution
        // --- Core Application Logic ---
        let scene, camera, renderer, controls, points, lines;
        let rootVectors8D = [];
        let lineIndices = [];
        let projectionMatrix;
        let frameCounter = 0;
        const phi = (1 + Math.sqrt(5)) / 2;
        
        // Animation parameters
        let rotationSpeed = 1.0;
        let autoRotate = true;
        
        // --- FPS Tracking (FIXED) ---
        const frameTimes = [];
        let lastFrameTime = performance.now();
        
        // --- 8D Math Engine (OPTIMIZED) ---
        // Pre-allocate reusable matrices to avoid garbage collection stutter
        const R1 = create8DIdentity();
        const R2 = create8DIdentity();
        const R3 = create8DIdentity();
        const R_temp = create8DIdentity();
        const R = create8DIdentity();
        const rotatedVec = new Array(8).fill(0);

        // --- 1. DATA GENERATION ---
        function generateE8Data() {
            console.log("Generating E8 root system...");
            
            // Type 1 roots
            for (let i = 0; i < 8; i++) {
                for (let j = i + 1; j < 8; j++) {
                    for (const s1 of [-1, 1]) {
                        for (const s2 of [-1, 1]) {
                            const vec = new Array(8).fill(0);
                            vec[i] = s1;
                            vec[j] = s2;
                            rootVectors8D.push(vec);
                        }
                    }
                }
            }
            
            // Type 2 roots
            function generateSignCombinations(n, current = []) {
                if (n === 0) {
                    if (current.filter(x => x === -1).length % 2 === 0) {
                        rootVectors8D.push(current.map(s => s * 0.5));
                    }
                    return;
                }
                generateSignCombinations(n - 1, current.concat(1));
                generateSignCombinations(n - 1, current.concat(-1));
            }
            generateSignCombinations(8);
            
            console.log(`Generated ${rootVectors8D.length} roots.`);
            document.getElementById('vertex-count').textContent = rootVectors8D.length;
            
            // Find line segments
            for (let i = 0; i < rootVectors8D.length; i++) {
                for (let j = i + 1; j < rootVectors8D.length; j++) {
                    let ip = 0;
                    for (let k = 0; k < 8; k++) {
                        ip += rootVectors8D[i][k] * rootVectors8D[j][k];
                    }
                    if (Math.abs(ip + 1.0) < 1e-9) {
                        lineIndices.push(i, j);
                    }
                }
            }
            console.log(`Found ${lineIndices.length / 2} line segments.`);
            document.getElementById('line-count').textContent = lineIndices.length / 2;
        }
        
        // --- 2. 8D Math Helpers (OPTIMIZED) ---
        function create8DIdentity() {
            const matrix = Array(8).fill(0).map(() => Array(8).fill(0));
            for (let i = 0; i < 8; i++) matrix[i][i] = 1;
            return matrix;
        }
        
        function getRotationMatrix8D(theta, i, j, out) {
            // Reset to identity
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    out[r][c] = (r === c) ? 1 : 0;
                }
            }
            const cos_t = Math.cos(theta);
            const sin_t = Math.sin(theta);
            out[i][i] = cos_t; out[i][j] = -sin_t;
            out[j][i] = sin_t; out[j][j] = cos_t;
        }
        
        function multiplyMatrices8D(A, B, out) {
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    let sum = 0;
                    for (let k = 0; k < 8; k++) {
                        sum += A[i][k] * B[k][j];
                    }
                    out[i][j] = sum;
                }
            }
        }
        
        function applyMatrixToVector8D(M, v, out) {
            for (let i = 0; i < 8; i++) {
                let sum = 0;
                for (let j = 0; j < 8; j++) {
                    sum += M[i][j] * v[j];
                }
                out[i] = sum;
            }
        }
        
        // --- 3. THREE.JS / WEBGL SETUP ---
        function init() {
            generateE8Data();
            
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 5, 15);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 3;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const pointLight1 = new THREE.PointLight(0x00ffff, 1, 100);
            pointLight1.position.set(5, 5, 5);
            scene.add(pointLight1);
            const pointLight2 = new THREE.PointLight(0xff00ff, 0.8, 100);
            pointLight2.position.set(-5, -5, 5);
            scene.add(pointLight2);
            
            // Create geometries
            const pointGeometry = new THREE.BufferGeometry();
            const lineGeometry = new THREE.BufferGeometry();
            
            const positions = new Float32Array(rootVectors8D.length * 3);
            const colors = new Float32Array(rootVectors8D.length * 3);
            
            // Generate colors
            for (let i = 0; i < rootVectors8D.length; i++) {
                const vec = rootVectors8D[i];
                const angle = Math.atan2(vec[1], vec[0]);
                const hue = (angle + Math.PI) / (2 * Math.PI);
                const rgb = hslToRgb(hue, 1, 0.6);
                colors[i * 3] = rgb[0];
                colors[i * 3 + 1] = rgb[1];
                colors[i * 3 + 2] = rgb[2];
            }
            
            const positionAttribute = new THREE.BufferAttribute(positions, 3);
            pointGeometry.setAttribute('position', positionAttribute);
            pointGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            lineGeometry.setAttribute('position', positionAttribute); // Share the same position attribute
            lineGeometry.setIndex(lineIndices);
            
            // --- FIX: Create a circular texture to make points spherical ---
            const canvasTexture = document.createElement('canvas');
            canvasTexture.width = 64;
            canvasTexture.height = 64;
            const context = canvasTexture.getContext('2d');
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.5)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 64, 64);
            const pointTexture = new THREE.CanvasTexture(canvasTexture);
            
            // Create materials
            const pointMaterial = new THREE.PointsMaterial({
                size: 0.1,
                map: pointTexture, // Apply the circular texture
                vertexColors: true,
                transparent: true,
                alphaTest: 0.1, // Discard fully transparent pixels
                blending: THREE.NormalBlending,
                sizeAttenuation: true
            });
            
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.2,
                blending: THREE.AdditiveBlending
            });
            
            points = new THREE.Points(pointGeometry, pointMaterial);
            lines = new THREE.LineSegments(lineGeometry, lineMaterial);
            scene.add(points);
            scene.add(lines);
            
            projectionMatrix = [
                [0., -0.55679344, 0.19694925, -0.19694925, 0.08054772, -0.38529087, 0., 0.38529087],
                [0.18091315, 0., 0.16021295, 0.16021295, 0., 0.09901705, 0.76636042, 0.09901705],
                [0.33826121, 0, 0, -0.33826121, 0.67281636, 0.17150256, 0, -0.17150256]
            ];
            
            setupControls();
            applyPreset('cosmic'); // Start with a cool preset
        }
        
        // HSL to RGB conversion
        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) { r = g = b = l; } 
            else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [r, g, b];
        }
        
        // Setup control listeners
        function setupControls() {
            document.getElementById('rotation-speed').addEventListener('input', (e) => {
                rotationSpeed = parseFloat(e.target.value);
                document.getElementById('speed-value').textContent = rotationSpeed.toFixed(1) + 'x';
            });
            
            document.getElementById('point-size').addEventListener('input', (e) => {
                const size = parseFloat(e.target.value);
                points.material.size = size;
                document.getElementById('size-value').textContent = size.toFixed(2);
            });
            
            document.getElementById('line-opacity').addEventListener('input', (e) => {
                const opacity = parseFloat(e.target.value);
                lines.material.opacity = opacity;
                document.getElementById('line-opacity-value').textContent = opacity.toFixed(2);
            });
            
            document.getElementById('glow-intensity').addEventListener('input', (e) => {
                const glowIntensity = parseFloat(e.target.value);
                points.material.opacity = 0.5 + glowIntensity * 0.3;
                document.getElementById('glow-value').textContent = glowIntensity.toFixed(1);
            });
            
            document.getElementById('camera-distance').addEventListener('input', (e) => {
                const distance = parseFloat(e.target.value);
                camera.position.setLength(distance);
                document.getElementById('distance-value').textContent = distance.toFixed(1);
            });
            
            document.getElementById('auto-rotate').addEventListener('change', (e) => {
                autoRotate = e.target.checked;
            });
            
            document.getElementById('show-lines').addEventListener('change', (e) => {
                lines.visible = e.target.checked;
            });
            
            document.getElementById('bloom-effect').addEventListener('change', (e) => {
                points.material.blending = e.target.checked ? THREE.AdditiveBlending : THREE.NormalBlending;
            });
        }
        
        // --- 4. ANIMATION LOOP (FIXED FPS COUNTER & LINE MOVEMENT) ---
        function animate() {
            requestAnimationFrame(animate);
            
            // --- Robust FPS Counter ---
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            
            frameTimes.push(deltaTime);
            if (frameTimes.length > 60) {
                frameTimes.shift();
            }
            
            const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
            const fps = Math.round(1000 / avgFrameTime);
            document.getElementById('fps-counter').textContent = `FPS: ${fps}`;

            // --- Rotation Logic ---
            if (autoRotate) {
                const theta = 0.005 * frameCounter * rotationSpeed;
                getRotationMatrix8D(theta, 0, 1, R1);
                getRotationMatrix8D(theta * phi, 2, 3, R2);
                getRotationMatrix8D(theta * phi * phi, 4, 5, R3);
                
                multiplyMatrices8D(R1, R2, R_temp);
                multiplyMatrices8D(R_temp, R3, R);
                
                const pointPositions = points.geometry.attributes.position.array;
                
                for (let i = 0; i < rootVectors8D.length; i++) {
                    applyMatrixToVector8D(R, rootVectors8D[i], rotatedVec);
                    
                    const x = rotatedVec.reduce((sum, val, idx) => sum + val * projectionMatrix[0][idx], 0);
                    const y = rotatedVec.reduce((sum, val, idx) => sum + val * projectionMatrix[1][idx], 0);
                    const z = rotatedVec.reduce((sum, val, idx) => sum + val * projectionMatrix[2][idx], 0);
                    
                    pointPositions[i * 3] = x;
                    pointPositions[i * 3 + 1] = y;
                    pointPositions[i * 3 + 2] = z;
                }
                
                // Tell three.js to update the position data
                points.geometry.attributes.position.needsUpdate = true;
                
                frameCounter++;
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Preset configurations
        function applyPreset(preset) {
            switch(preset) {
                case 'cosmic':
                    document.getElementById('rotation-speed').value = 0.8;
                    document.getElementById('point-size').value = 0.12;
                    document.getElementById('line-opacity').value = 0.3;
                    document.getElementById('glow-intensity').value = 1.2;
                    document.getElementById('bloom-effect').checked = true;
                    break;
                case 'neon':
                    document.getElementById('rotation-speed').value = 2.0;
                    document.getElementById('point-size').value = 0.15;
                    document.getElementById('line-opacity').value = 0.5;
                    document.getElementById('glow-intensity').value = 1.8;
                    document.getElementById('bloom-effect').checked = true;
                    break;
                case 'minimal':
                    document.getElementById('rotation-speed').value = 0.5;
                    document.getElementById('point-size').value = 0.06;
                    document.getElementById('line-opacity').value = 0.1;
                    document.getElementById('glow-intensity').value = 0.2;
                    document.getElementById('bloom-effect').checked = false;
                    break;
                case 'intense':
                    document.getElementById('rotation-speed').value = 3.5;
                    document.getElementById('point-size').value = 0.2;
                    document.getElementById('line-opacity').value = 0.7;
                    document.getElementById('glow-intensity').value = 2.0;
                    document.getElementById('bloom-effect').checked = true;
                    break;
            }
            // Trigger change events to update visuals and UI
            document.querySelectorAll('input').forEach(input => {
                input.dispatchEvent(new Event('input'));
                input.dispatchEvent(new Event('change'));
            });
        }
        
        // Attach functions to the global window object to make them accessible from HTML
        window.resetCamera = function() {
            camera.position.set(0, 0, 3);
            controls.reset();
        }
        
        window.randomizeRotation = function() {
            frameCounter = Math.random() * 10000;
            const newSpeed = 1 + Math.random() * 3;
            document.getElementById('rotation-speed').value = newSpeed;
            document.getElementById('rotation-speed').dispatchEvent(new Event('input'));
        }
        
        window.togglePanel = function() {
            const panel = document.getElementById('info-panel');
            const currentOpacity = panel.style.opacity === '0' ? '0' : '1';
            panel.style.opacity = currentOpacity === '1' ? '0' : '1';
            panel.style.pointerEvents = currentOpacity === '1' ? 'none' : 'auto';
        }
        
        window.applyPreset = applyPreset;

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);
        
        // Start the application
        init();
        animate();
    })(); // End of IIFE
    </script>
</body>
</html>

